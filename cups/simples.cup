import java_cup.runtime.*;
import java.util.*;
import java.util.Deque;
import java.util.ArrayDeque;

parser code {:
    // --- Funções de erro ---
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder(">> Erro");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) m.append(" na linha "+(s.left+1)+", coluna "+(s.right+1));
        }
        m.append(": ").append(message);
        System.err.println(m);
    }
    public void report_fatal_error(String message, Object info) { report_error(message, info); throw new RuntimeException("Erro Fatal"); }

    // --- ARQUITETURA DE GERAÇÃO DE CÓDIGO ---
    private StringBuilder mainCode = new StringBuilder();
    private StringBuilder functionsCode = new StringBuilder();
    private boolean parsingFunction = false; 
    private int indent_level = 1;

    private StringBuilder getBuffer() { return parsingFunction ? functionsCode : mainCode; }
    private void indent() { for(int i=0; i<indent_level*4; i++) getBuffer().append(" "); }

    public void emit_final_code() {
        System.out.println("#include <stdio.h>\n#include <stdlib.h>\n");
        System.out.print(functionsCode.toString());
        System.out.println("int main() {");
        System.out.print(mainCode.toString());
        System.out.println("    return 0;\n}");
    }

    // --- Tabela de Símbolos e Estruturas Auxiliares ---
    class TabelaSimbolo {
        String tipo; boolean ehVetor;
        TabelaSimbolo(String t, boolean v) { this.tipo = t; this.ehVetor = v; }
        public String getTipo() { return tipo; }
        public boolean getEhVetor() { return ehVetor; }
    }
    private Hashtable<String, TabelaSimbolo> dicionario = new Hashtable<>();
    private Deque<String> pilhaAuxiliar = new ArrayDeque<>();
    
    // --- FUNÇÕES DE CHECAGEM SEMÂNTICA ---
    public String checkExpr(String e1, String e2) {
        String tipoE1 = null, tipoE2 = null;
        if (e1 != null) {
            if (e1.startsWith("\"")) { tipoE1 = "STRING"; }
            else if (e1.matches("-?\\d+")) { tipoE1 = "INT"; }
            else if (e1.matches("-?\\d+\\.\\d+")) { tipoE1 = "FLOAT"; }
            else {
                String idBase1 = e1.contains("[") ? e1.substring(0, e1.indexOf('[')) : e1;
                if (dicionario.containsKey(idBase1)) tipoE1 = dicionario.get(idBase1).getTipo();
                else report_fatal_error("Variavel ou expressao '" + e1 + "' nao reconhecida.", null);
            }
        }
        if (e2 != null) {
            if (e2.matches("-?\\d+")) { tipoE2 = "INT"; }
            else if (e2.matches("-?\\d+\\.\\d+")) { tipoE2 = "FLOAT"; }
            else {
                String idBase2 = e2.contains("[") ? e2.substring(0, e2.indexOf('[')) : e2;
                if (dicionario.containsKey(idBase2)) tipoE2 = dicionario.get(idBase2).getTipo();
                else report_fatal_error("Variavel ou expressao '" + e2 + "' nao reconhecida.", null);
            }
        }
        if (tipoE1 != null && tipoE2 != null && !tipoE1.equals(tipoE2)) {
            report_fatal_error("Operacao com tipos incompativeis: " + tipoE1 + " e " + tipoE2, null);
        }
        return tipoE1 != null ? tipoE1 : tipoE2;
    }
    
    // --- FUNÇÕES DE EMISSÃO DE CÓDIGO ---
    public void emit_bloco_inicio() { indent(); getBuffer().append("{\n"); indent_level++; }
    public void emit_bloco_fim() { indent_level--; indent(); getBuffer().append("}\n"); }

    public void emit_escreva(String content, boolean newline) {
        indent();
        String tipo = checkExpr(content, null);
        if (tipo.equals("STRING")) {
            String literal = content.substring(1, content.length() - 1);
            if (newline) literal += "\\n";
            getBuffer().append("printf(\"" + literal + "\");\n");
        } else {
            String format = tipo.equals("INT") ? "%d" : "%f";
            if (newline) format += "\\n";
            getBuffer().append("printf(\"" + format + "\", " + content + ");\n");
        }
    }
:};

/* --- DECLARAÇÕES DE TERMINAIS E NÃO-TERMINAIS --- */
terminal PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN, LBRCKT, RBRCKT, EQUALS, GREATER, LESS;
terminal PROGRAM, STARTPRG, ENDPRG, READLINE, WRITELINE, WRITELN, DECLINT, DECLFLOAT, SEMI;
terminal E, OU, NAO, IFF, THENN, ELSEE, ENDELSE, ATTRIB, PARA, DE, ATE, PASSO, FACA, FIMPARA;
terminal ENQUANTO, FIMENQUANTO, PROCEDIMENTO, UNARY;
terminal String ID, INTT, FLOATT, STRING_LITERAL;

non terminal program, list_command, command, assign, declare_variable, writel, writeln, readl, if_stmt, else_part, for_stmt, while_stmt;
non terminal proc_declaration, list_proc_declaration;
non terminal String expr, tipo, vetor;

/* --- PRECEDÊNCIAS --- */
precedence left E, OU;
precedence nonassoc NAO;
precedence nonassoc EQUALS, GREATER, LESS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UNARY;

/* --- GRAMÁTICA --- */
start with program;

program ::= list_proc_declaration PROGRAM STARTPRG list_command ENDPRG {: emit_final_code(); :};

list_proc_declaration ::= list_proc_declaration proc_declaration | /* empty */;

proc_declaration ::= PROCEDIMENTO tipo:t ID:id LPAREN RPAREN 
                     {: parsingFunction = true; indent_level = 1; getBuffer().append("\n" + (t.equals("INT")?"int":"float") + " " + id + "() "); :}
                     STARTPRG {: emit_bloco_inicio(); :} list_command ENDPRG {: emit_bloco_fim(); parsingFunction = false; :};

list_command ::= list_command command | /* empty */;

command ::= declare_variable | assign | writel | writeln | readl | if_stmt | for_stmt | while_stmt;

tipo ::= DECLINT:t {: RESULT = "INT"; :} | DECLFLOAT:t {: RESULT = "FLOAT"; :};

declare_variable ::= 
    tipo:t ID:id SEMI 
        {:  if(dicionario.containsKey(id)) report_fatal_error("Variavel duplicada: " + id,id);
            dicionario.put(id, new TabelaSimbolo(t,false)); 
            indent(); getBuffer().append((t.equals("INT")?"int":"float") + " " + id + ";\n"); :}
    | tipo:t ID:id ATTRIB expr:v SEMI 
        {:  if(dicionario.containsKey(id)) report_fatal_error("Variavel duplicada: " + id,id);
            String tipoExpr = checkExpr(v, null); 
            if (!t.equals(tipoExpr)) report_fatal_error("Erro de tipo na atribuicao da variavel '"+id+"'. Esperado "+t+" mas recebeu "+tipoExpr, null);
            dicionario.put(id, new TabelaSimbolo(t,false));
            indent(); getBuffer().append((t.equals("INT")?"int":"float") + " " + id + " = " + v + ";\n"); :}
    | tipo:t vetor:v SEMI 
        {:  String id = pilhaAuxiliar.pop(); String tam = pilhaAuxiliar.pop();
            if(dicionario.containsKey(id)) report_fatal_error("Variavel duplicada: " + id,id);
            if (!checkExpr(tam, null).equals("INT")) report_fatal_error("Tamanho do vetor '"+id+"' deve ser um inteiro.", null);
            dicionario.put(id, new TabelaSimbolo(t,true));
            indent(); getBuffer().append((t.equals("INT")?"int":"float") + " " + id + "[" + tam + "];\n"); :};

vetor ::= ID:i LBRCKT expr:z RBRCKT {: pilhaAuxiliar.push(z); pilhaAuxiliar.push(i); :};

assign ::= 
    ID:id ATTRIB expr:v SEMI 
        {:  checkExpr(id, v); indent(); getBuffer().append(id + " = " + v + ";\n"); :}
    | ID:i LBRCKT expr:idx RBRCKT ATTRIB expr:v SEMI 
        {:  checkExpr(i+"["+idx+"]", v); indent(); getBuffer().append(i + "[" + idx + "]" + " = " + v + ";\n"); :};

readl ::= READLINE ID:id SEMI 
        {:  TabelaSimbolo t1 = dicionario.get(id);
            if(t1 == null) report_fatal_error("Variavel '"+id+"' nao declarada.", null);
            indent(); getBuffer().append("scanf(\""+ (t1.getTipo().equals("INT")?"%d":"%f") +"\", &" + id + ");\n"); :};

writel ::= 
      WRITELINE expr:v SEMI {: emit_escreva(v, false); :}
    | WRITELINE STRING_LITERAL:s SEMI {: emit_escreva("\"" + s + "\"", false); :};

writeln ::= 
      WRITELN expr:v SEMI {: emit_escreva(v, true); :}
    | WRITELN STRING_LITERAL:s SEMI {: emit_escreva("\"" + s + "\"", true); :};

if_stmt ::= IFF expr:cond THENN {: indent(); getBuffer().append("if (" + cond + ") "); emit_bloco_inicio(); :}
            list_command else_part ENDELSE;

else_part ::= ELSEE {: indent_level--; indent(); getBuffer().append("} else "); emit_bloco_inicio(); :} list_command {: emit_bloco_fim(); :}
            | {: emit_bloco_fim(); :}; 

for_stmt ::= PARA ID:id DE expr:d ATE expr:a PASSO expr:p FACA 
             {:  if (!dicionario.containsKey(id)) report_fatal_error("Variavel '"+id+"' do loop FOR nao declarada.", null);
                 boolean neg = false; try { if(Integer.parseInt(p)<0) neg=true; } catch(Exception e){}
                 indent(); getBuffer().append("for(" + id + " = " + d + "; " + id + (neg ? " >= " : " <= ") + a + "; " + id + " += " + p + ") "); :}
             {: emit_bloco_inicio(); :} list_command FIMPARA {: emit_bloco_fim(); :};

while_stmt ::= ENQUANTO expr:cond FACA {: indent(); getBuffer().append("while (" + cond + ") "); :}
               {: emit_bloco_inicio(); :} list_command FIMENQUANTO {: emit_bloco_fim(); :};

expr ::= expr:e1 PLUS expr:e2      
            {: String tipo = checkExpr(e1, e2); RESULT = e1 + " + " + e2; dicionario.put(RESULT, new TabelaSimbolo(tipo, false)); :}
       | expr:e1 MINUS expr:e2     
            {: String tipo = checkExpr(e1, e2); RESULT = e1 + " - " + e2; dicionario.put(RESULT, new TabelaSimbolo(tipo, false)); :}
       | expr:e1 TIMES expr:e2     
            {: String tipo = checkExpr(e1, e2); RESULT = e1 + " * " + e2; dicionario.put(RESULT, new TabelaSimbolo(tipo, false)); :}
       | expr:e1 DIVIDE expr:e2    
            {: String tipo = checkExpr(e1, e2); RESULT = e1 + " / " + e2; dicionario.put(RESULT, new TabelaSimbolo(tipo, false)); :}
       | expr:e1 EQUALS expr:e2    
            {: checkExpr(e1, e2); RESULT = e1 + " == " + e2; :}
       | expr:e1 GREATER expr:e2   
            {: checkExpr(e1, e2); RESULT = e1 + " > " + e2; :}
       | expr:e1 LESS expr:e2      
            {: checkExpr(e1, e2); RESULT = e1 + " < " + e2; :}
       | expr:e1 E expr:e2         
            {: checkExpr(e1, e2); RESULT = e1 + " && " + e2; :}
       | expr:e1 OU expr:e2        
            {: checkExpr(e1, e2); RESULT = e1 + " || " + e2; :}
       | NAO expr:e1               
            {: checkExpr(e1, null); RESULT = "!" + e1; :}
       | MINUS expr:e1             
            {: String tipo = checkExpr(e1, null); RESULT = "-" + e1; dicionario.put(RESULT, new TabelaSimbolo(tipo, false));:} %prec UNARY
       | LPAREN expr:e1 RPAREN     
            {: String tipo = checkExpr(e1, null); RESULT = "(" + e1 + ")"; dicionario.put(RESULT, new TabelaSimbolo(tipo, false)); :}
       | ID:i LBRCKT expr:idx RBRCKT 
            {: String tipo = checkExpr(i, null); if(!checkExpr(idx, null).equals("INT")) report_fatal_error("Indice de vetor deve ser um inteiro.", null); RESULT = i + "[" + idx + "]"; dicionario.put(RESULT, new TabelaSimbolo(tipo, true)); :}
       | ID:i                      
            {: checkExpr(i, null); RESULT = i; :}
       | INTT:n                    
            {: RESULT = n; dicionario.put(n, new TabelaSimbolo("INT", false)); :}
       | FLOATT:n                  
            {: RESULT = n; dicionario.put(n, new TabelaSimbolo("FLOAT", false)); :};